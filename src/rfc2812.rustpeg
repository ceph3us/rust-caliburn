use rfc2812_types::{Message, Prefix, Command};
use rfc2812_types::Prefix::{User, Server};
use rfc2812_types::Command::{Verb, Numeric};

#[pub]
irc_msg -> Message<'input>
  = pre:prefix? cmd:command ps:params? { Message { prefix: pre, command: cmd, params: ps } }

prefix -> Prefix<'input>
  = ":" t:host " " { Server(t) }
  / ":" n:nickname hs:host_segment? " " {
    match hs {
      Some(seg) => {
        let (u, h) = seg;
        User { nickname: n, user: u, host: Some(h) }
      },
      None => User { nickname: n, user: None, host: None }
    }
  }

#[pub]
host -> &'input str
  = h:hostname { match_str }
  / hostaddr { match_str }

#[pub]
nickname -> &'input str
  = [a-zA-Z0-9\x5B-\x60\x7B-\x7D] nick_str { match_str }

nick_char
  = [a-zA-Z0-9\x5B-\x60\x7B-\x7D\-]

nick_str -> &'input str
  = nick_char{1,} { match_str }

hostname -> &'input str
  = shortname ** "." { match_str }

shortname
  = [a-zA-Z0-9] [a-zA-Z0-9\-]* [a-zA-Z0-9]*

hostaddr -> &'input str
  = ip4addr { match_str }

ip4addr
  = digit{1,3} "." digit{1,3} "." digit{1,3} "." digit{1,3}

host_segment -> (Option<&'input str>, &'input str)
  = u:username? "@" h:host { (u, h) }

username -> &'input str
  = "!" u:nick_str { u }

nospacecrlf -> &'input str
  = [\x01-\x09\x0B-\x0C\x0E-\x1F\x21-\x39\x3B-\xFF]+ { match_str }

trailing -> &'input str
  = [\x01-\x09\x0B-\x0C\x0E-\x1F\x21-\x39\x3B-\xFF :]+ { match_str }

letters -> &'input str
  = [a-zA-Z]+ {
    let result = match_str;
    result
  }

digit
  = [0-9]

hexdigit
  = [0-9A-F]

numeric -> &'input str
  = digit{3} { match_str }

command -> Command<'input>
  = letters { Verb(match_str) }
  / numeric { Numeric(match_str.parse().unwrap()) }

params -> Vec<&'input str>
  = m:middle_params? l:last_param {
    match m {
      Some(params) => {
        let mut out = params;
        out.push(l.clone());
        out
      }
      None => {
        vec![l.clone()]
      }
    }
  }

middle_param -> &'input str
  = " " s:nospacecrlf { s }

middle_params -> Vec<&'input str>
  = middle_param{1,14}

last_param -> &'input str
  = " " ":" t:trailing { t }
