// Generated by rust-peg. Do not edit.
#![allow(non_snake_case, unused)]
use line_parser::{Message, Prefix, Command};
use line_parser::Prefix::{User, Server, NoPrefix};
use line_parser::Command::{Verb, Numeric};
use self::RuleResult::{Matched, Failed};
fn escape_default(s: &str) -> String {
    s.chars().flat_map(|c| c.escape_default()).collect()
}
fn char_range_at(s: &str, pos: usize) -> (char, usize) {
    let c = &s[pos..].chars().next().unwrap();
    let next_pos = pos + c.len_utf8();
    (*c, next_pos)
}
#[derive(Clone)]
enum RuleResult<T> { Matched(usize, T), Failed, }
#[derive(PartialEq, Eq, Debug, Clone)]
pub struct ParseError {
    pub line: usize,
    pub column: usize,
    pub offset: usize,
    pub expected: ::std::collections::HashSet<&'static str>,
}
pub type ParseResult<T> = Result<T, ParseError>;
impl ::std::fmt::Display for ParseError {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter)
     -> ::std::result::Result<(), ::std::fmt::Error> {
        try!(write ! (
             fmt , "error at {}:{}: expected " , self . line , self . column
             ));
        if self.expected.len() == 0 {
            try!(write ! ( fmt , "EOF" ));
        } else if self.expected.len() == 1 {
            try!(write ! (
                 fmt , "`{}`" , escape_default (
                 self . expected . iter (  ) . next (  ) . unwrap (  ) ) ));
        } else {
            let mut iter = self.expected.iter();
            try!(write ! (
                 fmt , "one of `{}`" , escape_default (
                 iter . next (  ) . unwrap (  ) ) ));
            for elem in iter {
                try!(write ! ( fmt , ", `{}`" , escape_default ( elem ) ));
            }
        }
        Ok(())
    }
}
impl ::std::error::Error for ParseError {
    fn description(&self) -> &str { "parse error" }
}
fn slice_eq(input: &str, state: &mut ParseState, pos: usize, m: &'static str)
 -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    let l = m.len();
    if input.len() >= pos + l &&
           &input.as_bytes()[pos..pos + l] == m.as_bytes() {
        Matched(pos + l, ())
    } else { state.mark_failure(pos, m) }
}
fn slice_eq_case_insensitive(input: &str, state: &mut ParseState, pos: usize,
                             m: &'static str) -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    let mut used = 0usize;
    let mut input_iter = input[pos..].chars().flat_map(|x| x.to_uppercase());
    for m_char_upper in m.chars().flat_map(|x| x.to_uppercase()) {
        used += m_char_upper.len_utf8();
        let input_char_result = input_iter.next();
        if input_char_result.is_none() ||
               input_char_result.unwrap() != m_char_upper {
            return state.mark_failure(pos, m);
        }
    }
    Matched(pos + used, ())
}
fn any_char(input: &str, state: &mut ParseState, pos: usize)
 -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    if input.len() > pos {
        let (_, next) = char_range_at(input, pos);
        Matched(next, ())
    } else { state.mark_failure(pos, "<character>") }
}
fn pos_to_line(input: &str, pos: usize) -> (usize, usize) {
    let mut remaining = pos;
    let mut lineno: usize = 1;
    for line in input.lines() {
        let line_length = line.len() + 1;
        if remaining < line_length { return (lineno, remaining + 1); }
        remaining -= line_length;
        lineno += 1;
    }
    return (lineno, remaining + 1);
}
struct ParseState {
    max_err_pos: usize,
    expected: ::std::collections::HashSet<&'static str>,
}
impl ParseState {
    fn new() -> ParseState {
        ParseState{max_err_pos: 0,
                   expected: ::std::collections::HashSet::new(),}
    }
    fn mark_failure(&mut self, pos: usize, expected: &'static str)
     -> RuleResult<()> {
        if pos > self.max_err_pos {
            self.max_err_pos = pos;
            self.expected.clear();
        }
        if pos == self.max_err_pos { self.expected.insert(expected); }
        Failed
    }
}
fn parse_irc_msg<'input>(input: &'input str, state: &mut ParseState,
                         pos: usize) -> RuleResult<Message<'input>> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "irc_msg" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res =
                        match parse_prefix(input, state, pos) {
                            Matched(newpos, value) => {
                                Matched(newpos, Some(value))
                            }
                            Failed => { Matched(pos, None) }
                        };
                    match seq_res {
                        Matched(pos, pre) => {
                            {
                                let seq_res =
                                    parse_command(input, state, pos);
                                match seq_res {
                                    Matched(pos, cmd) => {
                                        {
                                            let seq_res =
                                                match parse_params(input,
                                                                   state, pos)
                                                    {
                                                    Matched(newpos, value) =>
                                                    {
                                                        Matched(newpos,
                                                                Some(value))
                                                    }
                                                    Failed => {
                                                        Matched(pos, None)
                                                    }
                                                };
                                            match seq_res {
                                                Matched(pos, ps) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos,
                                                                {
                                                                    Message{prefix:
                                                                                match pre
                                                                                    {
                                                                                    Some(res)
                                                                                    =>
                                                                                    res,
                                                                                    None
                                                                                    =>
                                                                                    NoPrefix,
                                                                                },
                                                                            command:
                                                                                cmd,
                                                                            params:
                                                                                match ps
                                                                                    {
                                                                                    Some(ps)
                                                                                    =>
                                                                                    ps,
                                                                                    None
                                                                                    =>
                                                                                    vec!(),
                                                                                },}
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "irc_msg" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "irc_msg" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_prefix<'input>(input: &'input str, state: &mut ParseState,
                        pos: usize) -> RuleResult<Prefix<'input>> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "prefix" , line , col , pos);
        let mut __peg_closure = || {
            {
                let choice_res =
                    {
                        let start_pos = pos;
                        {
                            let seq_res = slice_eq(input, state, pos, ":");
                            match seq_res {
                                Matched(pos, _) => {
                                    {
                                        let seq_res =
                                            parse_host(input, state, pos);
                                        match seq_res {
                                            Matched(pos, t) => {
                                                {
                                                    let seq_res =
                                                        slice_eq(input, state,
                                                                 pos, " ");
                                                    match seq_res {
                                                        Matched(pos, _) => {
                                                            {
                                                                let match_str =
                                                                    &input[start_pos..pos];
                                                                Matched(pos,
                                                                        {
                                                                            Server(t)
                                                                        })
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let start_pos = pos;
                        {
                            let seq_res = slice_eq(input, state, pos, ":");
                            match seq_res {
                                Matched(pos, _) => {
                                    {
                                        let seq_res =
                                            parse_nickname(input, state, pos);
                                        match seq_res {
                                            Matched(pos, n) => {
                                                {
                                                    let seq_res =
                                                        match parse_host_segment(input,
                                                                                 state,
                                                                                 pos)
                                                            {
                                                            Matched(newpos,
                                                                    value) =>
                                                            {
                                                                Matched(newpos,
                                                                        Some(value))
                                                            }
                                                            Failed => {
                                                                Matched(pos,
                                                                        None)
                                                            }
                                                        };
                                                    match seq_res {
                                                        Matched(pos, hs) => {
                                                            {
                                                                let seq_res =
                                                                    slice_eq(input,
                                                                             state,
                                                                             pos,
                                                                             " ");
                                                                match seq_res
                                                                    {
                                                                    Matched(pos,
                                                                            _)
                                                                    => {
                                                                        {
                                                                            let match_str =
                                                                                &input[start_pos..pos];
                                                                            Matched(pos,
                                                                                    {
                                                                                        match hs
                                                                                            {
                                                                                            Some(seg)
                                                                                            =>
                                                                                            {
                                                                                                let (u,
                                                                                                     h) =
                                                                                                    seg;
                                                                                                User{nickname:
                                                                                                         n,
                                                                                                     user:
                                                                                                         u,
                                                                                                     host:
                                                                                                         Some(h),}
                                                                                            }
                                                                                            None
                                                                                            =>
                                                                                            User{nickname:
                                                                                                     n,
                                                                                                 user:
                                                                                                     None,
                                                                                                 host:
                                                                                                     None,},
                                                                                        }
                                                                                    })
                                                                        }
                                                                    }
                                                                    Failed =>
                                                                    Failed,
                                                                }
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "prefix" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "prefix" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_host<'input>(input: &'input str, state: &mut ParseState, pos: usize)
 -> RuleResult<&'input str> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "host" , line , col , pos);
        let mut __peg_closure = || {
            {
                let choice_res =
                    {
                        let start_pos = pos;
                        {
                            let seq_res = parse_hostaddr(input, state, pos);
                            match seq_res {
                                Matched(pos, _) => {
                                    {
                                        let match_str =
                                            &input[start_pos..pos];
                                        Matched(pos, { match_str })
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let start_pos = pos;
                        {
                            let seq_res = parse_hostname(input, state, pos);
                            match seq_res {
                                Matched(pos, _) => {
                                    {
                                        let match_str =
                                            &input[start_pos..pos];
                                        Matched(pos, { match_str })
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" , "host"
                     , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "host" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_nickname<'input>(input: &'input str, state: &mut ParseState,
                          pos: usize) -> RuleResult<&'input str> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "nickname" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res =
                        if input.len() > pos {
                            let (ch, next) = char_range_at(input, pos);
                            match ch {
                                'a' ...'z' | 'A' ...'Z' | '0' ...'9' | '['
                                ...'`' | '{' ...'}' => Matched(next, ()),
                                _ =>
                                state.mark_failure(pos, "[a-zA-Z0-9[-`{-}]"),
                            }
                        } else {
                            state.mark_failure(pos, "[a-zA-Z0-9[-`{-}]")
                        };
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    parse_nick_str(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let match_str =
                                                &input[start_pos..pos];
                                            Matched(pos, { match_str })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "nickname" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "nickname" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_nick_char<'input>(input: &'input str, state: &mut ParseState,
                           pos: usize) -> RuleResult<()> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "nick_char" , line , col , pos);
        let mut __peg_closure = || {
            if input.len() > pos {
                let (ch, next) = char_range_at(input, pos);
                match ch {
                    'a' ...'z' | 'A' ...'Z' | '0' ...'9' | '[' ...'`' | '{'
                    ...'}' | '-' => Matched(next, ()),
                    _ => state.mark_failure(pos, "[a-zA-Z0-9[-`{-}-]"),
                }
            } else { state.mark_failure(pos, "[a-zA-Z0-9[-`{-}-]") } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "nick_char" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "nick_char" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_nick_str<'input>(input: &'input str, state: &mut ParseState,
                          pos: usize) -> RuleResult<&'input str> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "nick_str" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            let mut repeat_value = vec!();
                            loop  {
                                let pos = repeat_pos;
                                let step_res =
                                    parse_nick_char(input, state, pos);
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                        repeat_value.push(value);
                                    }
                                    Failed => { break ; }
                                }
                            }
                            if repeat_value.len() >= 1usize {
                                Matched(repeat_pos, ())
                            } else { Failed }
                        };
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { match_str })
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "nick_str" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "nick_str" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_hostname<'input>(input: &'input str, state: &mut ParseState,
                          pos: usize) -> RuleResult<&'input str> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "hostname" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            let mut repeat_value = vec!();
                            loop  {
                                let pos = repeat_pos;
                                let pos =
                                    if repeat_value.len() > 0 {
                                        let sep_res =
                                            slice_eq(input, state, pos, ".");
                                        match sep_res {
                                            Matched(newpos, _) => { newpos }
                                            Failed => break ,
                                        }
                                    } else { pos };
                                let step_res =
                                    parse_shortname(input, state, pos);
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                        repeat_value.push(value);
                                    }
                                    Failed => { break ; }
                                }
                            }
                            Matched(repeat_pos, ())
                        };
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { match_str })
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "hostname" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "hostname" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_shortname<'input>(input: &'input str, state: &mut ParseState,
                           pos: usize) -> RuleResult<()> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "shortname" , line , col , pos);
        let mut __peg_closure = || {
            {
                let seq_res =
                    if input.len() > pos {
                        let (ch, next) = char_range_at(input, pos);
                        match ch {
                            'a' ...'z' | 'A' ...'Z' | '0' ...'9' =>
                            Matched(next, ()),
                            _ => state.mark_failure(pos, "[a-zA-Z0-9]"),
                        }
                    } else { state.mark_failure(pos, "[a-zA-Z0-9]") };
                match seq_res {
                    Matched(pos, _) => {
                        {
                            let seq_res =
                                {
                                    let mut repeat_pos = pos;
                                    loop  {
                                        let pos = repeat_pos;
                                        let step_res =
                                            if input.len() > pos {
                                                let (ch, next) =
                                                    char_range_at(input, pos);
                                                match ch {
                                                    'a' ...'z' | 'A' ...'Z' |
                                                    '0' ...'9' | '-' | '/' =>
                                                    Matched(next, ()),
                                                    _ =>
                                                    state.mark_failure(pos,
                                                                       "[a-zA-Z0-9-/]"),
                                                }
                                            } else {
                                                state.mark_failure(pos,
                                                                   "[a-zA-Z0-9-/]")
                                            };
                                        match step_res {
                                            Matched(newpos, value) => {
                                                repeat_pos = newpos;
                                            }
                                            Failed => { break ; }
                                        }
                                    }
                                    Matched(repeat_pos, ())
                                };
                            match seq_res {
                                Matched(pos, _) => {
                                    {
                                        let mut repeat_pos = pos;
                                        loop  {
                                            let pos = repeat_pos;
                                            let step_res =
                                                if input.len() > pos {
                                                    let (ch, next) =
                                                        char_range_at(input,
                                                                      pos);
                                                    match ch {
                                                        'a' ...'z' | 'A'
                                                        ...'Z' | '0' ...'9' =>
                                                        Matched(next, ()),
                                                        _ =>
                                                        state.mark_failure(pos,
                                                                           "[a-zA-Z0-9]"),
                                                    }
                                                } else {
                                                    state.mark_failure(pos,
                                                                       "[a-zA-Z0-9]")
                                                };
                                            match step_res {
                                                Matched(newpos, value) => {
                                                    repeat_pos = newpos;
                                                }
                                                Failed => { break ; }
                                            }
                                        }
                                        Matched(repeat_pos, ())
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    }
                    Failed => Failed,
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "shortname" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "shortname" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_hostaddr<'input>(input: &'input str, state: &mut ParseState,
                          pos: usize) -> RuleResult<&'input str> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "hostaddr" , line , col , pos);
        let mut __peg_closure = || {
            {
                let choice_res =
                    {
                        let start_pos = pos;
                        {
                            let seq_res = parse_ip4addr(input, state, pos);
                            match seq_res {
                                Matched(pos, _) => {
                                    {
                                        let match_str =
                                            &input[start_pos..pos];
                                        Matched(pos, { match_str })
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let start_pos = pos;
                        {
                            let seq_res = parse_ip6addr(input, state, pos);
                            match seq_res {
                                Matched(pos, _) => {
                                    {
                                        let match_str =
                                            &input[start_pos..pos];
                                        Matched(pos, { match_str })
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "hostaddr" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "hostaddr" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_ip4addr<'input>(input: &'input str, state: &mut ParseState,
                         pos: usize) -> RuleResult<()> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "ip4addr" , line , col , pos);
        let mut __peg_closure = || {
            {
                let seq_res =
                    {
                        let mut repeat_pos = pos;
                        let mut repeat_value = vec!();
                        loop  {
                            let pos = repeat_pos;
                            if repeat_value.len() >= 3usize { break  }
                            let step_res = parse_digit(input, state, pos);
                            match step_res {
                                Matched(newpos, value) => {
                                    repeat_pos = newpos;
                                    repeat_value.push(value);
                                }
                                Failed => { break ; }
                            }
                        }
                        if repeat_value.len() >= 1usize {
                            Matched(repeat_pos, ())
                        } else { Failed }
                    };
                match seq_res {
                    Matched(pos, _) => {
                        {
                            let seq_res = slice_eq(input, state, pos, ".");
                            match seq_res {
                                Matched(pos, _) => {
                                    {
                                        let seq_res =
                                            {
                                                let mut repeat_pos = pos;
                                                let mut repeat_value = vec!();
                                                loop  {
                                                    let pos = repeat_pos;
                                                    if repeat_value.len() >=
                                                           3usize {
                                                        break
                                                    }
                                                    let step_res =
                                                        parse_digit(input,
                                                                    state,
                                                                    pos);
                                                    match step_res {
                                                        Matched(newpos, value)
                                                        => {
                                                            repeat_pos =
                                                                newpos;
                                                            repeat_value.push(value);
                                                        }
                                                        Failed => { break ; }
                                                    }
                                                }
                                                if repeat_value.len() >=
                                                       1usize {
                                                    Matched(repeat_pos, ())
                                                } else { Failed }
                                            };
                                        match seq_res {
                                            Matched(pos, _) => {
                                                {
                                                    let seq_res =
                                                        slice_eq(input, state,
                                                                 pos, ".");
                                                    match seq_res {
                                                        Matched(pos, _) => {
                                                            {
                                                                let seq_res =
                                                                    {
                                                                        let mut repeat_pos =
                                                                            pos;
                                                                        let mut repeat_value =
                                                                            vec!();
                                                                        loop 
                                                                             {
                                                                            let pos =
                                                                                repeat_pos;
                                                                            if repeat_value.len()
                                                                                   >=
                                                                                   3usize
                                                                               {
                                                                                break

                                                                            }
                                                                            let step_res =
                                                                                parse_digit(input,
                                                                                            state,
                                                                                            pos);
                                                                            match step_res
                                                                                {
                                                                                Matched(newpos,
                                                                                        value)
                                                                                =>
                                                                                {
                                                                                    repeat_pos
                                                                                        =
                                                                                        newpos;
                                                                                    repeat_value.push(value);
                                                                                }
                                                                                Failed
                                                                                =>
                                                                                {
                                                                                    break
                                                                                        ;
                                                                                }
                                                                            }
                                                                        }
                                                                        if repeat_value.len()
                                                                               >=
                                                                               1usize
                                                                           {
                                                                            Matched(repeat_pos,
                                                                                    ())
                                                                        } else {
                                                                            Failed
                                                                        }
                                                                    };
                                                                match seq_res
                                                                    {
                                                                    Matched(pos,
                                                                            _)
                                                                    => {
                                                                        {
                                                                            let seq_res =
                                                                                slice_eq(input,
                                                                                         state,
                                                                                         pos,
                                                                                         ".");
                                                                            match seq_res
                                                                                {
                                                                                Matched(pos,
                                                                                        _)
                                                                                =>
                                                                                {
                                                                                    {
                                                                                        let mut repeat_pos =
                                                                                            pos;
                                                                                        let mut repeat_value =
                                                                                            vec!();
                                                                                        loop 
                                                                                             {
                                                                                            let pos =
                                                                                                repeat_pos;
                                                                                            if repeat_value.len()
                                                                                                   >=
                                                                                                   3usize
                                                                                               {
                                                                                                break

                                                                                            }
                                                                                            let step_res =
                                                                                                parse_digit(input,
                                                                                                            state,
                                                                                                            pos);
                                                                                            match step_res
                                                                                                {
                                                                                                Matched(newpos,
                                                                                                        value)
                                                                                                =>
                                                                                                {
                                                                                                    repeat_pos
                                                                                                        =
                                                                                                        newpos;
                                                                                                    repeat_value.push(value);
                                                                                                }
                                                                                                Failed
                                                                                                =>
                                                                                                {
                                                                                                    break
                                                                                                        ;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        if repeat_value.len()
                                                                                               >=
                                                                                               1usize
                                                                                           {
                                                                                            Matched(repeat_pos,
                                                                                                    ())
                                                                                        } else {
                                                                                            Failed
                                                                                        }
                                                                                    }
                                                                                }
                                                                                Failed
                                                                                =>
                                                                                Failed,
                                                                            }
                                                                        }
                                                                    }
                                                                    Failed =>
                                                                    Failed,
                                                                }
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    }
                    Failed => Failed,
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "ip4addr" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "ip4addr" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_ip6addr_trailing_seg_upper<'input>(input: &'input str,
                                            state: &mut ParseState,
                                            pos: usize) -> RuleResult<()> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "ip6addr_trailing_seg_upper" , line , col , pos);
        let mut __peg_closure = || {
            {
                let seq_res = slice_eq(input, state, pos, ":");
                match seq_res {
                    Matched(pos, _) => {
                        {
                            let mut repeat_pos = pos;
                            let mut repeat_value = vec!();
                            loop  {
                                let pos = repeat_pos;
                                if repeat_value.len() >= 4usize { break  }
                                let step_res =
                                    parse_hexdigit_upper(input, state, pos);
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                        repeat_value.push(value);
                                    }
                                    Failed => { break ; }
                                }
                            }
                            if repeat_value.len() >= 1usize {
                                Matched(repeat_pos, ())
                            } else { Failed }
                        }
                    }
                    Failed => Failed,
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "ip6addr_trailing_seg_upper" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "ip6addr_trailing_seg_upper" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_ip6addr_trailing_seg_lower<'input>(input: &'input str,
                                            state: &mut ParseState,
                                            pos: usize) -> RuleResult<()> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "ip6addr_trailing_seg_lower" , line , col , pos);
        let mut __peg_closure = || {
            {
                let seq_res = slice_eq(input, state, pos, ":");
                match seq_res {
                    Matched(pos, _) => {
                        {
                            let mut repeat_pos = pos;
                            let mut repeat_value = vec!();
                            loop  {
                                let pos = repeat_pos;
                                if repeat_value.len() >= 4usize { break  }
                                let step_res =
                                    parse_hexdigit_lower(input, state, pos);
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                        repeat_value.push(value);
                                    }
                                    Failed => { break ; }
                                }
                            }
                            if repeat_value.len() >= 1usize {
                                Matched(repeat_pos, ())
                            } else { Failed }
                        }
                    }
                    Failed => Failed,
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "ip6addr_trailing_seg_lower" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "ip6addr_trailing_seg_lower" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_ip6addr<'input>(input: &'input str, state: &mut ParseState,
                         pos: usize) -> RuleResult<()> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "ip6addr" , line , col , pos);
        let mut __peg_closure = || {
            {
                let choice_res =
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    if repeat_value.len() >= 4usize { break  }
                                    let step_res =
                                        parse_hexdigit_upper(input, state,
                                                             pos);
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                if repeat_value.len() >= 1usize {
                                    Matched(repeat_pos, ())
                                } else { Failed }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let mut repeat_pos = pos;
                                    let mut repeat_value = vec!();
                                    loop  {
                                        let pos = repeat_pos;
                                        if repeat_value.len() >= 7usize {
                                            break
                                        }
                                        let step_res =
                                            parse_ip6addr_trailing_seg_upper(input,
                                                                             state,
                                                                             pos);
                                        match step_res {
                                            Matched(newpos, value) => {
                                                repeat_pos = newpos;
                                                repeat_value.push(value);
                                            }
                                            Failed => { break ; }
                                        }
                                    }
                                    if repeat_value.len() >= 7usize {
                                        Matched(repeat_pos, ())
                                    } else { Failed }
                                }
                            }
                            Failed => Failed,
                        }
                    };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            {
                                let seq_res =
                                    {
                                        let mut repeat_pos = pos;
                                        let mut repeat_value = vec!();
                                        loop  {
                                            let pos = repeat_pos;
                                            if repeat_value.len() >= 4usize {
                                                break
                                            }
                                            let step_res =
                                                parse_hexdigit_lower(input,
                                                                     state,
                                                                     pos);
                                            match step_res {
                                                Matched(newpos, value) => {
                                                    repeat_pos = newpos;
                                                    repeat_value.push(value);
                                                }
                                                Failed => { break ; }
                                            }
                                        }
                                        if repeat_value.len() >= 1usize {
                                            Matched(repeat_pos, ())
                                        } else { Failed }
                                    };
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let mut repeat_pos = pos;
                                            let mut repeat_value = vec!();
                                            loop  {
                                                let pos = repeat_pos;
                                                if repeat_value.len() >=
                                                       7usize {
                                                    break
                                                }
                                                let step_res =
                                                    parse_ip6addr_trailing_seg_lower(input,
                                                                                     state,
                                                                                     pos);
                                                match step_res {
                                                    Matched(newpos, value) =>
                                                    {
                                                        repeat_pos = newpos;
                                                        repeat_value.push(value);
                                                    }
                                                    Failed => { break ; }
                                                }
                                            }
                                            if repeat_value.len() >= 7usize {
                                                Matched(repeat_pos, ())
                                            } else { Failed }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            };
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let seq_res =
                                    slice_eq(input, state, pos, "0:0:0:0:0:");
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                {
                                                    let choice_res =
                                                        slice_eq(input, state,
                                                                 pos, "FFFF");
                                                    match choice_res {
                                                        Matched(pos, value) =>
                                                        Matched(pos, value),
                                                        Failed => {
                                                            let choice_res =
                                                                slice_eq(input,
                                                                         state,
                                                                         pos,
                                                                         "ffff");
                                                            match choice_res {
                                                                Matched(pos,
                                                                        value)
                                                                =>
                                                                Matched(pos,
                                                                        value),
                                                                Failed =>
                                                                slice_eq(input,
                                                                         state,
                                                                         pos,
                                                                         "0"),
                                                            }
                                                        }
                                                    }
                                                };
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let seq_res =
                                                            slice_eq(input,
                                                                     state,
                                                                     pos,
                                                                     ":");
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                parse_ip4addr(input,
                                                                              state,
                                                                              pos)
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "ip6addr" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "ip6addr" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_host_segment<'input>(input: &'input str, state: &mut ParseState,
                              pos: usize)
 -> RuleResult<(Option<&'input str>, &'input str)> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "host_segment" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res =
                        match parse_username(input, state, pos) {
                            Matched(newpos, value) => {
                                Matched(newpos, Some(value))
                            }
                            Failed => { Matched(pos, None) }
                        };
                    match seq_res {
                        Matched(pos, u) => {
                            {
                                let seq_res =
                                    slice_eq(input, state, pos, "@");
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                parse_host(input, state, pos);
                                            match seq_res {
                                                Matched(pos, h) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos,
                                                                { (u, h) })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "host_segment" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "host_segment" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_username<'input>(input: &'input str, state: &mut ParseState,
                          pos: usize) -> RuleResult<&'input str> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "username" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "!");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    parse_nick_str(input, state, pos);
                                match seq_res {
                                    Matched(pos, u) => {
                                        {
                                            let match_str =
                                                &input[start_pos..pos];
                                            Matched(pos, { u })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "username" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "username" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_nospacecrlf<'input>(input: &'input str, state: &mut ParseState,
                             pos: usize) -> RuleResult<&'input str> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "nospacecrlf" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            let mut repeat_value = vec!();
                            loop  {
                                let pos = repeat_pos;
                                let step_res =
                                    if input.len() > pos {
                                        let (ch, next) =
                                            char_range_at(input, pos);
                                        match ch {
                                            '\u{1}' ...'\t' | '\u{b}'
                                            ...'\u{c}' | '\u{e}' ...'\u{1f}' |
                                            '!' ...'9' | ';' ...'\u{ff}' =>
                                            Matched(next, ()),
                                            _ =>
                                            state.mark_failure(pos,
                                                               "[\u{1}-\t\u{b}-\u{c}\u{e}-\u{1f}!-9;-\u{ff}]"),
                                        }
                                    } else {
                                        state.mark_failure(pos,
                                                           "[\u{1}-\t\u{b}-\u{c}\u{e}-\u{1f}!-9;-\u{ff}]")
                                    };
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                        repeat_value.push(value);
                                    }
                                    Failed => { break ; }
                                }
                            }
                            if repeat_value.len() >= 1usize {
                                Matched(repeat_pos, ())
                            } else { Failed }
                        };
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { match_str })
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "nospacecrlf" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "nospacecrlf" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_trailing<'input>(input: &'input str, state: &mut ParseState,
                          pos: usize) -> RuleResult<&'input str> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "trailing" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            let mut repeat_value = vec!();
                            loop  {
                                let pos = repeat_pos;
                                let step_res =
                                    if input.len() > pos {
                                        let (ch, next) =
                                            char_range_at(input, pos);
                                        match ch {
                                            '\u{1}' ...'\t' | '\u{b}'
                                            ...'\u{c}' | '\u{e}' ...'\u{1f}' |
                                            '!' ...'9' | ';' ...'\u{ff}' | ' '
                                            | ':' => Matched(next, ()),
                                            _ =>
                                            state.mark_failure(pos,
                                                               "[\u{1}-\t\u{b}-\u{c}\u{e}-\u{1f}!-9;-\u{ff} :]"),
                                        }
                                    } else {
                                        state.mark_failure(pos,
                                                           "[\u{1}-\t\u{b}-\u{c}\u{e}-\u{1f}!-9;-\u{ff} :]")
                                    };
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                        repeat_value.push(value);
                                    }
                                    Failed => { break ; }
                                }
                            }
                            if repeat_value.len() >= 1usize {
                                Matched(repeat_pos, ())
                            } else { Failed }
                        };
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { match_str })
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "trailing" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "trailing" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_letters<'input>(input: &'input str, state: &mut ParseState,
                         pos: usize) -> RuleResult<&'input str> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "letters" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            let mut repeat_value = vec!();
                            loop  {
                                let pos = repeat_pos;
                                let step_res =
                                    if input.len() > pos {
                                        let (ch, next) =
                                            char_range_at(input, pos);
                                        match ch {
                                            'a' ...'z' | 'A' ...'Z' =>
                                            Matched(next, ()),
                                            _ =>
                                            state.mark_failure(pos,
                                                               "[a-zA-Z]"),
                                        }
                                    } else {
                                        state.mark_failure(pos, "[a-zA-Z]")
                                    };
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                        repeat_value.push(value);
                                    }
                                    Failed => { break ; }
                                }
                            }
                            if repeat_value.len() >= 1usize {
                                Matched(repeat_pos, ())
                            } else { Failed }
                        };
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos,
                                        { let result = match_str; result })
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "letters" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "letters" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_digit<'input>(input: &'input str, state: &mut ParseState, pos: usize)
 -> RuleResult<()> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "digit" , line , col , pos);
        let mut __peg_closure = || {
            if input.len() > pos {
                let (ch, next) = char_range_at(input, pos);
                match ch {
                    '0' ...'9' => Matched(next, ()),
                    _ => state.mark_failure(pos, "[0-9]"),
                }
            } else { state.mark_failure(pos, "[0-9]") } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" , "digit"
                     , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "digit" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_hexdigit_upper<'input>(input: &'input str, state: &mut ParseState,
                                pos: usize) -> RuleResult<()> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "hexdigit_upper" , line , col , pos);
        let mut __peg_closure = || {
            {
                let choice_res = parse_digit(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => slice_eq(input, state, pos, "A"),
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "hexdigit_upper" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "hexdigit_upper" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_hexdigit_lower<'input>(input: &'input str, state: &mut ParseState,
                                pos: usize) -> RuleResult<()> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "hexdigit_lower" , line , col , pos);
        let mut __peg_closure = || { slice_eq(input, state, pos, "a") };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "hexdigit_lower" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "hexdigit_lower" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_numeric<'input>(input: &'input str, state: &mut ParseState,
                         pos: usize) -> RuleResult<&'input str> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "numeric" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            let mut repeat_value = vec!();
                            loop  {
                                let pos = repeat_pos;
                                if repeat_value.len() >= 3usize { break  }
                                let step_res = parse_digit(input, state, pos);
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                        repeat_value.push(value);
                                    }
                                    Failed => { break ; }
                                }
                            }
                            if repeat_value.len() >= 3usize {
                                Matched(repeat_pos, ())
                            } else { Failed }
                        };
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { match_str })
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "numeric" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "numeric" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_command<'input>(input: &'input str, state: &mut ParseState,
                         pos: usize) -> RuleResult<Command<'input>> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "command" , line , col , pos);
        let mut __peg_closure = || {
            {
                let choice_res =
                    {
                        let start_pos = pos;
                        {
                            let seq_res =
                                {
                                    let mut repeat_pos = pos;
                                    let mut repeat_value = vec!();
                                    loop  {
                                        let pos = repeat_pos;
                                        let step_res =
                                            parse_letters(input, state, pos);
                                        match step_res {
                                            Matched(newpos, value) => {
                                                repeat_pos = newpos;
                                                repeat_value.push(value);
                                            }
                                            Failed => { break ; }
                                        }
                                    }
                                    if repeat_value.len() >= 1usize {
                                        Matched(repeat_pos, ())
                                    } else { Failed }
                                };
                            match seq_res {
                                Matched(pos, _) => {
                                    {
                                        let match_str =
                                            &input[start_pos..pos];
                                        Matched(pos, { Verb(match_str) })
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let start_pos = pos;
                        {
                            let seq_res = parse_numeric(input, state, pos);
                            match seq_res {
                                Matched(pos, _) => {
                                    {
                                        let match_str =
                                            &input[start_pos..pos];
                                        Matched(pos,
                                                {
                                                    Numeric(match_str.parse().unwrap())
                                                })
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "command" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "command" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_params<'input>(input: &'input str, state: &mut ParseState,
                        pos: usize) -> RuleResult<Vec<String>> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "params" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res =
                        match parse_middle_params(input, state, pos) {
                            Matched(newpos, value) => {
                                Matched(newpos, Some(value))
                            }
                            Failed => { Matched(pos, None) }
                        };
                    match seq_res {
                        Matched(pos, m) => {
                            {
                                let seq_res =
                                    match parse_last_param(input, state, pos)
                                        {
                                        Matched(newpos, value) => {
                                            Matched(newpos, Some(value))
                                        }
                                        Failed => { Matched(pos, None) }
                                    };
                                match seq_res {
                                    Matched(pos, l) => {
                                        {
                                            let match_str =
                                                &input[start_pos..pos];
                                            Matched(pos,
                                                    {
                                                        match m {
                                                            Some(params) => {
                                                                let mut out =
                                                                    params;
                                                                match l {
                                                                    Some(finalp)
                                                                    =>
                                                                    out.push(finalp),
                                                                    None =>
                                                                    (),
                                                                };
                                                                out
                                                            }
                                                            None => {
                                                                match l {
                                                                    Some(finalp)
                                                                    =>
                                                                    vec!(finalp),
                                                                    None =>
                                                                    vec!(),
                                                                }
                                                            }
                                                        }
                                                    })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "params" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "params" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_nospacecrlfcol<'input>(input: &'input str, state: &mut ParseState,
                                pos: usize) -> RuleResult<&'input str> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "nospacecrlfcol" , line , col , pos);
        let mut __peg_closure = || {
            {
                let choice_res = parse_nospacecrlf(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let start_pos = pos;
                        {
                            let seq_res = slice_eq(input, state, pos, ":");
                            match seq_res {
                                Matched(pos, _) => {
                                    {
                                        let match_str =
                                            &input[start_pos..pos];
                                        Matched(pos, { match_str })
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "nospacecrlfcol" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "nospacecrlfcol" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_middle_param<'input>(input: &'input str, state: &mut ParseState,
                              pos: usize) -> RuleResult<String> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "middle_param" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, " ");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    parse_nospacecrlf(input, state, pos);
                                match seq_res {
                                    Matched(pos, s) => {
                                        {
                                            let seq_res =
                                                {
                                                    let mut repeat_pos = pos;
                                                    let mut repeat_value =
                                                        vec!();
                                                    loop  {
                                                        let pos = repeat_pos;
                                                        let step_res =
                                                            parse_nospacecrlfcol(input,
                                                                                 state,
                                                                                 pos);
                                                        match step_res {
                                                            Matched(newpos,
                                                                    value) =>
                                                            {
                                                                repeat_pos =
                                                                    newpos;
                                                                repeat_value.push(value);
                                                            }
                                                            Failed => {
                                                                break ;
                                                            }
                                                        }
                                                    }
                                                    Matched(repeat_pos,
                                                            repeat_value)
                                                };
                                            match seq_res {
                                                Matched(pos, t) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos,
                                                                {
                                                                    let mut tmp =
                                                                        match_str.to_string();
                                                                    tmp.remove(0);
                                                                    tmp
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "middle_param" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "middle_param" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_middle_params<'input>(input: &'input str, state: &mut ParseState,
                               pos: usize) -> RuleResult<Vec<String>> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "middle_params" , line , col , pos);
        let mut __peg_closure = || {
            {
                let mut repeat_pos = pos;
                let mut repeat_value = vec!();
                loop  {
                    let pos = repeat_pos;
                    if repeat_value.len() >= 14usize { break  }
                    let step_res = parse_middle_param(input, state, pos);
                    match step_res {
                        Matched(newpos, value) => {
                            repeat_pos = newpos;
                            repeat_value.push(value);
                        }
                        Failed => { break ; }
                    }
                }
                if repeat_value.len() >= 1usize {
                    Matched(repeat_pos, repeat_value)
                } else { Failed }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "middle_params" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "middle_params" , line , col , pos),
        }
        __peg_result
    }
}
fn parse_last_param<'input>(input: &'input str, state: &mut ParseState,
                            pos: usize) -> RuleResult<String> {
    {
        let (line, col) = pos_to_line(input, pos);
        println!("[PEG_TRACE] Attempting to match rule {} at {}:{} (pos {})" ,
                 "last_param" , line , col , pos);
        let mut __peg_closure = || {
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, " ");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    slice_eq(input, state, pos, ":");
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                parse_trailing(input, state,
                                                               pos);
                                            match seq_res {
                                                Matched(pos, t) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos,
                                                                {
                                                                    t.to_string()
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            } };
        let __peg_result = __peg_closure();
        match __peg_result {
            Matched(_, _) =>
            println!("[PEG_TRACE] Matched rule {} at {}:{} (pos {})" ,
                     "last_param" , line , col , pos),
            Failed =>
            println!("[PEG_TRACE] Failed to match rule {} at {}:{} (pos {})" ,
                     "last_param" , line , col , pos),
        }
        __peg_result
    }
}
pub fn irc_msg<'input>(input: &'input str) -> ParseResult<Message<'input>> {
    let mut state = ParseState::new();
    match parse_irc_msg(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn host<'input>(input: &'input str) -> ParseResult<&'input str> {
    let mut state = ParseState::new();
    match parse_host(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
pub fn nickname<'input>(input: &'input str) -> ParseResult<&'input str> {
    let mut state = ParseState::new();
    match parse_nickname(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
